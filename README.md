# WebDevelopment

Отчет за четвертую и пятую недели:

1. Создал репозитории сервисы и контроллеры к каждой таблице в базе данных. 
2. Написал в основном стандартные crud методы
3. Переделал под generic repository и объединил все репо в unit of work
4. Ознакомился что такое JWT токены, добавил новую таблицу с юзерами где лежат логины и пароли для авторизации. Создал репозиторий для для таблицы, сервис и контроллер для таблицы с креденшелсами
5. Пароли при создании записи в таблицу с авторизационными данными зашифровал.
6. Базу данных обновил миграцией
7. Добавил Integration тесты для всех контроллеров, познакомился с анноцией CollectionDefinition для интеграционных тестов, решает проблема вызова и уничтожения сервисов для каждого отдельного теста. С аннотацией сервисы живут пока все тесты не пройдут.
8. Поигрался с ролями и клаймами, вытянул из клаймы роли и айдишника и в зависимости от роли метод getall в userController возсращает разную информацию.



Отчет за третью неделю:
Задача стояла ознакомиться с паттернами синглтон/фактори и повторить репозиторий. После прочитанного надо было релиазовать фэктори паттерн с почтовыми провайдерами. 
1. Вынес лишнюю логику из HostClient
2. Создал фабрику, которая в методе create по переданому енаму возвращает нужный интерфейс провайдера.
3. Класс базового провайдера имплементирует интерфейс провайдера с методом отправки нотификации и smtp хелпер, который настраивает smtp в методе SendEmailAsync и инвокает отправку письма.
4. В папке модель есть 2 класса со свойствами настройками, которые тянутся из аппсетинга, и валидаторы для свойств этих классов.  
5. Так как переделка настигла джобу в хостед сервисе, то надо переделать юнит тесты.
6. Переделал юнит тесты, добавил новых, подправил старые.
7. Ознакомился с билдер паттерном, пробовал применить к Smtp клиенту, не очень релеватный пример получился, так как в любом случае заполнять надо все поля для корректной отправки сообщения, отказался от приминения.

Отчет за вторую неделю:

1. Прочитал про hosted service, background tasks и добавил в проект реализацию вида CronJobService (https://codeburst.io/schedule-cron-jobs-using-hostedservice-in-asp-net-core-e17c47ba06) - возможно переделаю на обычную реализацию с https://www.quartz-scheduler.net/
2. Хостед сервис вызывает метод, который тянет из базы данным почтовые ящики должников по прохождению онбординг таска и высылает письмо с напоминанием. 
3. Рассмотрены Smtp клиент и как отправлять сообщения. Для отправки сообщений выбрана яндекс почта, так как гугл запретил несекьюрным приложениям работу с их аккаунтами (надо создавать проект в клауде).
4. Хостед клиент не хотел скопед dbcontex принимать, решилась проблема добавлением через scopedfactory. 
5. Также прочитал про хеширование и шифрование. Пароль от почты зашифровал и добавил декриптор в проект для его расшифровки.
6. Добавил проверку конструкторов на корректное подключение сервисов из DI. Согласно defencive codding
7. Добавил юнит тесты. Ознакомился и использовал Fluent Test Class 
8. Переделал хостед сервис на https://www.quartz-scheduler.net/


Отдельный отчет по работе с SQL:

(П)Ознакомился с Dapper, Ado.Net и EF Core. У каждого свои особенности и приемущества. 
В тот момент когда EF Core выглядит более похожим на код C#, с его операторами LINQ и методами расшерения, dapper и ADO.Net позволяют использовать чистые SQL запросы. 
На сколько я понял на выгрузках больших данных Dapper будет работать быстрее. 
На проекте сделал Scaffold базы данных, потом добавил две модели и через миграцию обновил базу данных. 
В БД помимо установки constraints default, сделал триггер в таблице Users, на insert берется таск из таблицы Tasks и заполняется таблица UserTasks.
Вся БД експотнута в SQL script, файл скрипта можно найти в папке deploy.


Первый отчет о проделанном за неделю:

1. Создан проект WebDevelopment.Api
2. В локальной базе данных созданы таблицы по оговоренной схеме
3. Созданы контроллеры для каждой таблицы из БД
4. Подключен ErrorHandlerMiddleware
5. Создан сервис для работы с UserController и интеграционные тесты для него.
6. Создана модели для *UserRequest и валидация через FluentValidation. Автовалидация добавлена в Program.cs
7. Добавлена аутентификация через ApiKey (папка Security), ключ передается через хеддер и сверяется с тем, что указан в appsettings. Делалось по примеру из предосталенного для ознакомления проекта.
8. Настроен swagger для отправки ключа через хеддер.
9. Поправлены тесты, добавлена тестовая аутентификация.
10. Добавлен новый проект WebDevelopment.Infrastructure, куда с использование Reverse engineering из БД вытянута модель и контекст.
11. Контекст подключен к API через DI и передана строка подключения из appsettings. 
12. В процессе работы была прочитана информация по настройке сваггера, про claim и авторизацию с аутентификацией, про SQL базы данных и таблицы, предосталены были примеры интересных SQL запросов.  

Отчет о прочтенном материале перед созданием аппа.
Прочитал:
1. database first and code first worflow
2. что такое ORM, типы и Dapper (+ EF, миграции, dbcontex, подключение к существующией DB через Scaffold-DbContext)
3. SQLClient, если точнее, то про SqlConnection Class и прошелся по ссылкам в статье https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection?view=dotnet-plat-ext-6.0
4. WebApi tutorial 
5. Repository pattern
6. Factory pattern
7. Background task с hosted service
8. бегло синтаксис и теорию SQL 
9. про domain driven design.
10. Stored Procedure
11. Attribute filters
12. Прочитал про FluentValidation, добавил в проект для метода post
13. Прочитал про ErrorHandlingMiddleware, добавил в проект
